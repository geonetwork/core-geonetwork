<?xml version="1.0" encoding="UTF-8"?>
<criteriaTypes xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../criteria-type.xsd">
    <type>
        <value>*//gmd:keyword/gco:CharacterString/text() = '@@value@@'__OR__*//gmd:keyword/gmd:PT_FreeText/gmd:textGroup/gmd:LocalisedCharacterString/text() = '@@value@@'</value>
        <type>XPATH</type>
        <name>Keyword</name>
        <allowArbitraryValue>false</allowArbitraryValue>
        <remote>
            <cacheTime>0</cacheTime> <!-- Don't cache -->
            <url>xml.search.keywords@json?pNewSearch=true&amp;maxResults=100&amp;pKeyword=@@search@@&amp;pTypeSearch=CONTAINS</url>

            <!-- The following 3 elements are functions (paramName) {function body} and will be converted to a javascript function
                 in the UI by pre-pending function to the body text -->
            <selectRecordArray>(data, scope) { return data[0] }</selectRecordArray>
            <selectLabelFunction>(record, scope) { return record.value['#text'] + ' (' + record.thesaurus.title + ')' }</selectLabelFunction>
            <selectValueFunction>(record, scope) { return record.value['#text'] }</selectValueFunction>
        </remote>
    </type>
    <type>
        <value>@@value@@</value>
        <type>GROUP</type>
        <name>Group</name>
        <allowArbitraryValue>true</allowArbitraryValue>
        <remote>
            <!--
                cacheTime > 0 indicates that the typeahead should download all values and cache them
                If cacheTime is < 0 then either the "values" element will be used or a remote search will be used for each completion.
            -->
            <cacheTime>60000</cacheTime> <!-- Cache for 1 minute -->
            <url>xml.group.list@json</url>

            <!-- The following 3 elements are functions (paramName) {function body} and will be converted to a javascript function
                 in the UI by pre-pending function to the body text
                 -->
            <selectRecordArray>(data, scope) { return data }</selectRecordArray>
            <selectLabelFunction>(record, scope) {
                var label = record.label[scope.lang] ? record.label[scope.lang] : record.name;
                return label +" ("+record.id +")";
            }
            </selectLabelFunction>
            <!-- selectTokensFunction is optional -->
            <selectTokensFunction>(record, scope) {
                var regex = /\s+/g;
                var tokenHash = {};
                var tokens = [];
                var addUniqueTokens = function (string) {
                    var parts = string.split(regex);
                    for (var i = 0; i &lt; parts.length; i++) {
                        var token = angular.lowercase(parts[i]);
                        if (!tokenHash[token]) {
                            tokens.push(token);
                            tokenHash[token] = true;
                        }
                    }
                }
                addUniqueTokens(record.name);
                for (var p in record.label) {
                    if (record.label.hasOwnProperty(p) &amp;&amp; typeof record.label === 'string') {
                        addUniqueTokens(record.label[p]);
                    }
                }

                return tokens;
                }</selectTokensFunction>
            <selectValueFunction>(record, scope) { return record.id }</selectValueFunction>
        </remote>
    </type>
</criteriaTypes>